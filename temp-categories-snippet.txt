// src/routes/categories.ts
import { Router, Response } from 'express';
import { z } from 'zod';
import { Prisma } from '@prisma/client';
import { prisma } from '../db/prisma';
import { requireAdmin } from '../middlewares/auth';
import { getPagination, buildPagedResponse } from '../utils/pagination';

const router = Router();

const createCategorySchema = z.object({
  name: z.string().min(1).max(100),
  parentId: z.number().int().positive().nullable().optional(),
});

const updateCategorySchema = createCategorySchema.partial();

function handleWriteError(err: unknown, path: string, res: Response) {
  console.error(err);
  if (
    err instanceof Prisma.PrismaClientKnownRequestError &&
    err.code === 'P2002'
  ) {
    return res.status(409).json({
      timestamp: new Date().toISOString(),
      path,
      status: 409,
      code: 'DUPLICATE_RESOURCE',
      message: 'Category name already exists.',
      details: null,
    });
  }

  return res.status(500).json({
    timestamp: new Date().toISOString(),
    path,
    status: 500,
    code: 'INTERNAL_SERVER_ERROR',
    message: '?œë²„ ?¤ë¥˜ë¡?ì¹´í…Œê³ ë¦¬ë¥?ì²˜ë¦¬?˜ì? ëª»í–ˆ?µë‹ˆ??',
    details: null,
  });
}

function parseCategoryId(raw: string, path: string, res: Response) {
  const id = Number(raw);
  if (!Number.isInteger(id) || id <= 0) {
    res.status(400).json({
      timestamp: new Date().toISOString(),
      path,
      status: 400,
      code: 'BAD_REQUEST',
      message: '? íš¨??ì¹´í…Œê³ ë¦¬ IDê°€ ?„ìš”?©ë‹ˆ??',
      details: { id: raw },
    });
    return null;
  }
  return id;
}

router.post('/', requireAdmin, async (req, res) => {
  const parsed = createCategorySchema.safeParse(req.body);
  if (!parsed.success) {
    return res.status(422).json({
      timestamp: new Date().toISOString(),
      path: '/categories',
      status: 422,
      code: 'VALIDATION_FAILED',
      message: 'ì¹´í…Œê³ ë¦¬ ?”ì²­ ë³¸ë¬¸???¬ë°”ë¥´ì? ?ŠìŠµ?ˆë‹¤.',
      details: parsed.error.flatten(),
    });
  }

  const { name, parentId } = parsed.data;

  try {
    if (parentId) {
      const parent = await prisma.category.findUnique({ where: { id: parentId } });
      if (!parent) {
        return res.status(404).json({
          timestamp: new Date().toISOString(),
          path: '/categories',
          status: 404,
          code: 'RESOURCE_NOT_FOUND',
          message: 'ë¶€ëª?ì¹´í…Œê³ ë¦¬ë¥?ì°¾ì„ ???†ìŠµ?ˆë‹¤.',
          details: { parentId },
        });
      }
    }

    const created = await prisma.category.create({
      data: {
        name,
        parentId: parentId ?? null,
      },
    });

    return res.status(201).json({
      status: 'CREATED',
      statusCode: 201,
      message: 'ì¹´í…Œê³ ë¦¬ê°€ ?ì„±?˜ì—ˆ?µë‹ˆ??',
      data: created,
    });
  } catch (err) {
    return handleWriteError(err, '/categories', res);
  }
});

router.get('/', async (req, res) => {
  const { keyword, parentId } = req.query as {
    keyword?: string;
    parentId?: string;
  };

  const pagination = getPagination(req.query, {
    defaultPage: 0,
    defaultSize: 10,
    maxSize: 50,
    defaultSort: 'name,ASC',
  });

  let orderBy: any = { name: 'asc' };
  if (pagination.sort) {
    const [fieldRaw, dirRaw] = pagination.sort.split(/[,:]/);
    const field = (fieldRaw ?? 'name').trim();
    const dir =
      (dirRaw ?? 'ASC').toUpperCase() === 'DESC' ? 'desc' : 'asc';
    const allowed = ['name', 'createdAt'];
    orderBy = { [allowed.includes(field) ? field : 'name']: dir };
  }

  const where: any = {};
  if (keyword && keyword.trim().length > 0) {
    where.name = { contains: keyword.trim() };
  }

  if (parentId !== undefined) {
    if (parentId === 'null' || parentId === 'root') {
      where.parentId = null;
    } else {
      const parsedParent = Number(parentId);
      if (!Number.isInteger(parsedParent) || parsedParent <= 0) {
        return res.status(400).json({
          timestamp: new Date().toISOString(),
          path: '/categories',
          status: 400,
          code: 'INVALID_QUERY_PARAM',
          message: 'parentId ì¿¼ë¦¬ê°’ì´ ?¬ë°”ë¥´ì? ?ŠìŠµ?ˆë‹¤.',
          details: { parentId },
        });
      }
      where.parentId = parsedParent;
    }
  }

  try {
    const [items, total] = await Promise.all([
      prisma.category.findMany({
        where,
        orderBy,
        skip: pagination.skip,
        take: pagination.take,
      }),
      prisma.category.count({ where }),
    ]);

    const paged = buildPagedResponse(items, total, {
      page: pagination.page,
      size: pagination.size,
      sort: pagination.sort,
    });

    return res.status(200).json({
      status: 'OK',
      statusCode: 200,
      message: 'ì¹´í…Œê³ ë¦¬ ëª©ë¡ ì¡°íšŒ???±ê³µ?ˆìŠµ?ˆë‹¤.',
      data: paged,
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({
      timestamp: new Date().toISOString(),
      path: '/categories',
      status: 500,
      code: 'INTERNAL_SERVER_ERROR',
      message: 'ì¹´í…Œê³ ë¦¬ ëª©ë¡??ì¡°íšŒ?˜ì? ëª»í–ˆ?µë‹ˆ??',
      details: null,
    });
  }
});

router.get('/:id', async (req, res) => {
  const id = parseCategoryId(req.params.id, req.path, res);
  if (id === null) return;

  try {
    const category = await prisma.category.findUnique({
      where: { id },
      include: {
        parent: { select: { id: true, name: true } },
        children: {
